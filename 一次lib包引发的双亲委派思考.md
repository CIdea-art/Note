起因：

版本更新上线，调用另一个平台报解密异常，该平台在其他环境调用过，代码无误，且配置一致无误

环境：windows、jdk8

分析：

1. 比对两个环境解密包的版本，版本号一致，排除解密包问题
2. 查询被调用平台的日志，响应正常，排除调用平台问题，那么就确定是解密过程的问题
3. 类路径覆盖，没有，有也是两个环境一起出问题，排除
4. 最后经人提醒架构组好像有对jdk做手脚，进去果然看到了低版本的解密包，确定问题

方案：

1. 删除jdk里低版本的解密包。但是不确定哪些服务在用这个低版本解密包，且服务器上很多java服务在跑，文件被占用着，难以删除
2. 装一个新的纯净版jdk，修改path或启动脚本的java_home，指定jdk

最终选定方案2，不影响其它服务

引发原因：

之前见识过类路径覆盖，用来修改引用包里面类的骚操作。这次的也是相似的覆盖，但是类在jdk目录的lib/ext里，于是想到了双亲委派模型。ext里的jar有一个专门的扩展类加载器`ExtClassLoader`处理，仅次于最顶层的启动类加载器`BootstrapClassLoader`，高于常用的应用程序类加载器`AppClassLoader`。`AppClassLoader`就是加载我们程序包内所有文件的加载器。

[^]: 复习一下双亲委派模型。当类加载器查找类和资源时，会先委托父类加载器去做，自己拿父类的结果，父类尝试无果时，自己查找。此过程向上递归，直到最顶层的BootstrapClassLoader。

在本案例中，委派先让`ExtClassLoader`加载了lib/ext里同路径的解密类，应用里的解密类就被忽略了。

[^]: 引申一下，为什么程序包里`/classes`里的类能先于`/lib`加载？同为`/lib`是根据`pom`顺序加载，具体在哪实现？

