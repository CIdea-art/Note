

前置：

（建议）数据页

# 结构

**Hash**

比较简单，就是hash图结合链表（HashMap）。

Memory引擎可用（InnoDB不支持，会强制变成BTREE）。hash直接访问，等值效率高，但因为hash的无序，不支持排序，不支持范围。

索引结构/方法

**BTREE**



> HASH和BTREE的思路在数据结构中很常见，本质是最原始的数组和链表

# 知识点

## 索引数据

- 聚簇索引，存储主键、页码、数据

- 非聚簇索引（二级索引），存储索引、页码、主键

## 索引类型

- PRIMARY

- NORMAL
- UNIQUE
- FULLTEXT

## 回表

`非聚簇索引`到`聚簇索引`中查找数据的过程就被称为**回表**。

由于`非聚簇索引`页只存储了索引和主键，如果使用`非聚簇索引`查询其它数据时，需要到`聚簇索引`页，此时称为**回表**，如果数据已包含在`非聚簇索引`页中，称为**覆盖索引**。

MySQL5.6之前，仅会判断联合索引的首列，联合索引中的其它列依旧要在回表中判断。

MySQL5.6及之后，对联合索引查询有优化，会在回表前完成联合索引所有列的判断，称为**索引下推**。

## 索引合并

索引合并（index merge）是从MySQL5.1开始引入的索引优化机制，在之前的MySQL版本中，一条sql多个查询条件只能使用一个索引，但是引入了索引合并机制之后，MySQL在**某些特殊**的情况下会扫描多个索引，然后将扫描结果进行合并

结果合并会为下面三种情况：

- 取交集（intersect）
- 取并集（union）
- 排序后取并集（sort-union）

## 索引成本

在日常生产中，一个表可能会存在多个索引，那么mysql在执行sql的时候是如何去判断该走哪个索引，或者是全表扫描呢？

mysql在选择索引的时候会根据索引的使用成本来判断

一条sql执行的成本大致分为两块

- IO成本，因为这些页都是在磁盘的，要想去判断首先得加载到内存，MySQL规定加载一个页的成本为1.0
- CPU成本，除了IO成本之外，还有条件判断的成本，也就是CPU成本。比如前面举的例子，你得判断加载的数据符不符合`where`条件，MySQL规定每判断一条数据花费的成本为0.2

当索引的成本和全表扫描的成本都计算完成之后，mysql会选择成本最低的索引来执行。

### 全表成本

mysql会对表进行数据统计，这个统计是大概，不是特别准，通过`show table status like '表名'`可以查看统计数据

比如这个表大致有多少条数据rows，以及聚簇索引所占的字节数data_length，由于默认是16kb，所以就可以计算出(data_length/1024/16)大概有多少个数据页。

所以全表扫描的成本就这么计算了

```
rows（行数） * 0.2（CPU判断成本） + data_length/1024/16（页数） * 1.0（页IO成本）
```

### 二级索引成本

mysq规定读取一个区间的成本跟读取一个页的IO成本是一样的，都是1.0。

> 扫描区间：假设查询条件为`name < '李四' and name > '赵六'`，此时就会产生两个扫描区间。

```
rows（行数） * 0.2（CPU判断成本） + 区间个数 * 1.0（区间IO成本）
```

### 回表成本

mysql规定每次回表也跟读取一个页的IO成本是一样，也是1.0。

回表的时候需要对从聚簇索引查出来的数据进行剩余查询条件的判断，就是CPU成本，大致为 条数 * 0.2

所以回表的成本大致为

```
rows * 1.2（回表IO成本 + CPU判断成本）
```

如果索引未对rows数量进行限制，回表成本很容易超过全表成本。

> 例如select * from table_name order by index_name;
>
> 这样的，都会直接全表扫描，索引只起到排序作用（`Using filesort`）

## 索引失效

- 不符和最左前缀匹配原则。违背索引排序性。

- 不等运算符（包含is not null）。

- or逻辑符。

- 索引重新计算。计算结果和索引原始值无关，无法使用索引结构。

- 类型隐式转换。`索引值转换了类型，不同类型的数据比较方式、排序不一样。如：11>2但是'11'<'2'`

  > where varchar = 1

- mysql统计数据误差较大。`统计计算的成本决定了mysql使用哪种方式。`

  > analyze table 表名，重新统计数据。

- 区间查询时，索引列 <= 大于等于页最大值的查询值，或索引列 >= 小于等于页最小值的查询值。等价查询全表，不如全表扫描，节约回表成本。在数据量少的自测中经常出现，很容易懵。

  > 反提一嘴，如果查询通过一个索引的页最大值、页最小值直接判断无数据，不用回表直接返回空，基本（未充足论证，有可能有其它类似索引）可以认为使用了这个索引。

- 排序不符合联合索引排序规则。

- 成本过大，改用全表。

## 建立原则

**单表适量**

​	每个索引都对应一个数据结构。

- 增、删时都要连带操作这个结构，改时也需要判断是否涉及索引列，增加耗时。

- 并且占用磁盘。

- 成本计算变量增多，更耗时。

**where、order by、group by索引**

​	索引基本排序。

> order by和区间查询对hash索引无效

**不适合频繁更新**

​	需要频繁移动在结构中的位置。

**区分度高**

​	如果区分度低，会导致回表行数多，成本大，不如直接全表扫描，只会徒增索引维护的成本。

**考虑索引覆盖**

​	减少回表。

# 优化

## 关联

内连接时，mysql会自动把小结果集的选为驱动表，所以大表的字段最好加上索引。左外连接时，左表会全表扫描，所以右边大表字段最好加上索引，右外连接同理。我们最好保证被驱动表上的字段建立了索引。

## 排序

- 尽量避免使用Using FileSort方式排序。
- order by语句使用索引最左前列或使用where子句与order by子句条件组合满足索引最左前列。
- where子句中如果出现索引范围查询会导致order by索引失效。

> where a=const order by b,c

## 分组



# 实验与思考

在随手实验中，由于数据量较小触发了几个特殊情况，导致索引失效，补充到上面了

# 参考

https://mp.weixin.qq.com/s/LuHhIaJNH_y3rvOkOYpo8A

https://mp.weixin.qq.com/s/2sssv-VB4-TYZe-9FZRGtA